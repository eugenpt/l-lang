<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L Language - Graph Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            background: #2c3e50;
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        #controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            padding: 0.5rem 1rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover {
            background: #2980b9;
        }

        button:active {
            transform: translateY(1px);
        }

        #file-input {
            display: none;
        }

        #cy {
            flex: 1;
            background: white;
            margin: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #instructions {
            background: #ecf0f1;
            padding: 1rem 2rem;
            border-top: 1px solid #bdc3c7;
            font-size: 0.85rem;
            color: #555;
        }

        #instructions strong {
            color: #2c3e50;
        }

        .mode-indicator {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: bold;
            display: none;
            z-index: 1000;
        }

        .mode-indicator.active {
            display: block;
        }

        .mode-indicator.edge-mode {
            background: rgba(241, 196, 15, 0.9);
        }

        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 150px;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 14px;
            border-bottom: 1px solid #ecf0f1;
        }

        .context-menu-item:last-child {
            border-bottom: none;
        }

        .context-menu-item:hover {
            background: #ecf0f1;
        }

        .context-menu-header {
            padding: 8px 12px;
            font-weight: bold;
            font-size: 12px;
            background: #f8f9fa;
            border-bottom: 1px solid #bdc3c7;
            color: #555;
        }

        #legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 100;
            font-size: 12px;
        }

        #legend h3 {
            margin: 0 0 0.5rem 0;
            font-size: 14px;
            color: #2c3e50;
        }

        .legend-section {
            margin-bottom: 0.75rem;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
            gap: 8px;
        }

        .legend-shape {
            width: 30px;
            height: 20px;
            display: inline-block;
            border: 2px solid;
        }

        .legend-line {
            width: 40px;
            height: 2px;
            display: inline-block;
        }

        .legend-label {
            font-size: 11px;
            color: #555;
        }

        /* Inline text editor */
        #inline-editor {
            position: absolute;
            background: white;
            border: 2px solid #3498db;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            font-family: inherit;
            z-index: 2000;
            display: none;
            min-width: 80px;
            max-width: 200px;
            outline: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            text-align: center;
            transform: translate(-50%, -50%);
        }

        #inline-editor:focus {
            border-color: #2980b9;
        }

        /* Info panel */
        #info-panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 300px;
            max-height: calc(100vh - 350px);
            background: white;
            border: 1px solid #bdc3c7;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 100;
            display: none;
            flex-direction: column;
        }

        #info-panel.active {
            display: flex;
        }

        .info-panel-header {
            background: #2c3e50;
            color: white;
            padding: 12px;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel-close {
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 0 4px;
        }

        .info-panel-close:hover {
            opacity: 0.8;
        }

        .info-panel-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .info-section {
            margin-bottom: 12px;
        }

        .info-section:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-weight: bold;
            font-size: 11px;
            color: #555;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .info-value {
            font-size: 13px;
            color: #2c3e50;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 4px;
            word-wrap: break-word;
        }

        .info-value.editable {
            cursor: pointer;
            border: 1px solid #e0e0e0;
        }

        .info-value.editable:hover {
            background: #ecf0f1;
            border-color: #bdc3c7;
        }

        .info-textarea {
            width: 100%;
            min-height: 80px;
            padding: 6px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-family: inherit;
            font-size: 13px;
            resize: vertical;
        }

        .info-textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .connection-list {
            font-size: 12px;
            color: #555;
        }

        .connection-item {
            padding: 4px 6px;
            margin: 2px 0;
            background: #f8f9fa;
            border-radius: 3px;
            border-left: 3px solid #3498db;
            cursor: pointer;
            transition: background 0.2s;
        }

        .connection-item:hover {
            background: #e8ecef;
        }

        .connection-item.incoming {
            border-left-color: #2ecc71;
        }

        .connection-item.outgoing {
            border-left-color: #e74c3c;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>L Language - Interactive Graph Editor</h1>
        <div id="controls">
            <button id="add-node-btn">Add Node (N)</button>
            <button id="save-btn">Save Graph (Ctrl+S)</button>
            <button id="load-btn">Load Graph</button>
            <input type="file" id="file-input" accept=".json">
            <button id="clear-btn">Clear Graph</button>
        </div>
    </div>

    <div style="position: relative; flex: 1; display: flex; flex-direction: column;">
        <div id="mode-indicator" class="mode-indicator"></div>
        <input type="text" id="inline-editor" />
        <div id="cy"></div>
        <div id="context-menu" class="context-menu"></div>
        <div id="info-panel">
            <div class="info-panel-header">
                <span id="info-panel-title">Info</span>
                <span class="info-panel-close" id="info-panel-close">&times;</span>
            </div>
            <div class="info-panel-content" id="info-panel-content"></div>
        </div>
        <div id="legend">
            <h3>Legend</h3>
            <div class="legend-section">
                <strong style="font-size: 11px; color: #555;">Node Types (Keys 1-5)</strong>
                <div id="node-legend"></div>
            </div>
            <div class="legend-section">
                <strong style="font-size: 11px; color: #555;">Edge Types (Key T to cycle)</strong>
                <div id="edge-legend"></div>
            </div>
        </div>
    </div>

    <div id="instructions">
        <strong>Node Operations:</strong> Click empty space or press 'N' to add node | Click to select | Double-click to edit label | Delete key to remove | Press 1-5 to change type |
        <strong>Edge Operations:</strong> Select node + press 'E' + click target to add edge | Double-click edge to edit label | Press T to cycle type | Delete key to remove edge |
        <strong>Context Menu:</strong> Right-click node or edge to change type
    </div>

    <script>
        // Type definitions - centralized configuration for node and edge types
        const NODE_TYPES = {
            concept: {
                label: 'Concept',
                shape: 'ellipse',
                color: '#3498db',
                borderColor: '#2980b9'
            },
            claim: {
                label: 'Claim',
                shape: 'round-rectangle',
                color: '#2ecc71',
                borderColor: '#27ae60'
            },
            evidence: {
                label: 'Evidence',
                shape: 'diamond',
                color: '#e67e22',
                borderColor: '#d35400'
            },
            method: {
                label: 'Method',
                shape: 'hexagon',
                color: '#9b59b6',
                borderColor: '#8e44ad'
            },
            result: {
                label: 'Result',
                shape: 'rectangle',
                color: '#f1c40f',
                borderColor: '#f39c12'
            }
        };

        const EDGE_TYPES = {
            supports: {
                label: 'supports',
                color: '#2ecc71',
                lineStyle: 'solid',
                width: 2
            },
            contradicts: {
                label: 'contradicts',
                color: '#e74c3c',
                lineStyle: 'solid',
                width: 2
            },
            derives_from: {
                label: 'derives from',
                color: '#3498db',
                lineStyle: 'dashed',
                width: 2
            },
            requires: {
                label: 'requires',
                color: '#95a5a6',
                lineStyle: 'dotted',
                width: 2
            },
            measures: {
                label: 'measures',
                color: '#9b59b6',
                lineStyle: 'solid',
                width: 2
            },
            uses: {
                label: 'uses',
                color: '#8b4513',
                lineStyle: 'solid',
                width: 2
            }
        };

        // Helper to get node type keys in order
        const NODE_TYPE_KEYS = Object.keys(NODE_TYPES);
        const EDGE_TYPE_KEYS = Object.keys(EDGE_TYPES);

        // Initialize Cytoscape
        const cy = cytoscape({
            container: document.getElementById('cy'),

            style: [
                // Base node style
                {
                    selector: 'node',
                    style: {
                        'label': 'data(label)',
                        'color': '#2c3e50',
                        'text-valign': 'center',
                        'text-halign': 'center',
                        'font-size': '12px',
                        'width': '60px',
                        'height': '60px',
                        'border-width': '2px',
                        'text-wrap': 'wrap',
                        'text-max-width': '80px',
                        // Dynamic styling based on type
                        'shape': function(ele) {
                            const type = ele.data('type') || 'concept';
                            return NODE_TYPES[type]?.shape || 'ellipse';
                        },
                        'background-color': function(ele) {
                            const type = ele.data('type') || 'concept';
                            return NODE_TYPES[type]?.color || '#3498db';
                        },
                        'border-color': function(ele) {
                            const type = ele.data('type') || 'concept';
                            return NODE_TYPES[type]?.borderColor || '#2980b9';
                        }
                    }
                },
                {
                    selector: 'node:selected',
                    style: {
                        'border-color': '#c0392b',
                        'border-width': '3px',
                        'overlay-opacity': 0.2,
                        'overlay-color': '#e74c3c'
                    }
                },
                // Base edge style
                {
                    selector: 'edge',
                    style: {
                        'target-arrow-shape': 'triangle',
                        'curve-style': 'bezier',
                        'label': 'data(label)',
                        'font-size': '10px',
                        'text-rotation': 'autorotate',
                        'text-margin-y': -10,
                        'color': '#555',
                        // Dynamic styling based on type
                        'width': function(ele) {
                            const type = ele.data('type') || 'supports';
                            return EDGE_TYPES[type]?.width || 2;
                        },
                        'line-color': function(ele) {
                            const type = ele.data('type') || 'supports';
                            return EDGE_TYPES[type]?.color || '#95a5a6';
                        },
                        'target-arrow-color': function(ele) {
                            const type = ele.data('type') || 'supports';
                            return EDGE_TYPES[type]?.color || '#95a5a6';
                        },
                        'line-style': function(ele) {
                            const type = ele.data('type') || 'supports';
                            return EDGE_TYPES[type]?.lineStyle || 'solid';
                        }
                    }
                },
                {
                    selector: 'edge:selected',
                    style: {
                        'width': 3,
                        'overlay-opacity': 0.2,
                        'overlay-color': '#e74c3c'
                    }
                }
            ],

            layout: {
                name: 'preset'
            },

            // Enable panning and zooming
            zoomingEnabled: true,
            userZoomingEnabled: true,
            panningEnabled: true,
            userPanningEnabled: true,
            boxSelectionEnabled: false,
            autoungrabify: false
        });

        // State management
        let nodeIdCounter = 1;
        let edgeIdCounter = 1;
        let edgeMode = false;
        let edgeModeSourceNode = null;
        let editingElement = null;

        // Mode indicator element
        const modeIndicator = document.getElementById('mode-indicator');

        // Context menu elements
        const contextMenu = document.getElementById('context-menu');
        let contextMenuTarget = null;

        // Inline editor elements
        const inlineEditor = document.getElementById('inline-editor');

        // Info panel elements
        const infoPanel = document.getElementById('info-panel');
        const infoPanelTitle = document.getElementById('info-panel-title');
        const infoPanelContent = document.getElementById('info-panel-content');
        const infoPanelClose = document.getElementById('info-panel-close');

        // Initialize legend
        function initializeLegend() {
            const nodeLegend = document.getElementById('node-legend');
            const edgeLegend = document.getElementById('edge-legend');

            // Add node types to legend
            NODE_TYPE_KEYS.forEach((typeKey, index) => {
                const type = NODE_TYPES[typeKey];
                const item = document.createElement('div');
                item.className = 'legend-item';

                const shape = document.createElement('span');
                shape.className = 'legend-shape';
                shape.style.backgroundColor = type.color;
                shape.style.borderColor = type.borderColor;

                // Approximate shape representation
                if (type.shape === 'ellipse') {
                    shape.style.borderRadius = '50%';
                } else if (type.shape === 'round-rectangle') {
                    shape.style.borderRadius = '8px';
                } else if (type.shape === 'diamond') {
                    shape.style.transform = 'rotate(45deg)';
                } else if (type.shape === 'hexagon') {
                    shape.style.clipPath = 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)';
                }

                const label = document.createElement('span');
                label.className = 'legend-label';
                label.textContent = `${index + 1}. ${type.label}`;

                item.appendChild(shape);
                item.appendChild(label);
                nodeLegend.appendChild(item);
            });

            // Add edge types to legend
            EDGE_TYPE_KEYS.forEach((typeKey) => {
                const type = EDGE_TYPES[typeKey];
                const item = document.createElement('div');
                item.className = 'legend-item';

                const line = document.createElement('span');
                line.className = 'legend-line';
                line.style.backgroundColor = type.color;

                if (type.lineStyle === 'dashed') {
                    line.style.backgroundImage = `linear-gradient(to right, ${type.color} 0%, ${type.color} 50%, transparent 50%, transparent 100%)`;
                    line.style.backgroundSize = '8px 2px';
                    line.style.backgroundColor = 'transparent';
                } else if (type.lineStyle === 'dotted') {
                    line.style.backgroundImage = `linear-gradient(to right, ${type.color} 0%, ${type.color} 25%, transparent 25%, transparent 100%)`;
                    line.style.backgroundSize = '6px 2px';
                    line.style.backgroundColor = 'transparent';
                }

                const label = document.createElement('span');
                label.className = 'legend-label';
                label.textContent = type.label;

                item.appendChild(line);
                item.appendChild(label);
                edgeLegend.appendChild(item);
            });
        }

        // Show context menu
        function showContextMenu(x, y, target) {
            contextMenuTarget = target;
            contextMenu.innerHTML = '';

            if (target.isNode()) {
                // Node context menu
                const header = document.createElement('div');
                header.className = 'context-menu-header';
                header.textContent = 'Change Node Type';
                contextMenu.appendChild(header);

                NODE_TYPE_KEYS.forEach((typeKey, index) => {
                    const type = NODE_TYPES[typeKey];
                    const item = document.createElement('div');
                    item.className = 'context-menu-item';
                    item.textContent = `${index + 1}. ${type.label}`;
                    item.onclick = () => {
                        changeNodeType(target, typeKey);
                        hideContextMenu();
                    };
                    contextMenu.appendChild(item);
                });

                // Add separator
                const separator = document.createElement('div');
                separator.className = 'context-menu-header';
                separator.textContent = 'Actions';
                contextMenu.appendChild(separator);

                // Add delete option
                const deleteItem = document.createElement('div');
                deleteItem.className = 'context-menu-item';
                deleteItem.textContent = '🗑 Delete Node';
                deleteItem.style.color = '#e74c3c';
                deleteItem.onclick = () => {
                    cy.remove(target);
                    hideInfoPanel();
                    hideContextMenu();
                };
                contextMenu.appendChild(deleteItem);

            } else if (target.isEdge()) {
                // Edge context menu
                const header = document.createElement('div');
                header.className = 'context-menu-header';
                header.textContent = 'Change Edge Type';
                contextMenu.appendChild(header);

                EDGE_TYPE_KEYS.forEach((typeKey) => {
                    const type = EDGE_TYPES[typeKey];
                    const item = document.createElement('div');
                    item.className = 'context-menu-item';
                    item.textContent = type.label;
                    item.onclick = () => {
                        changeEdgeType(target, typeKey);
                        hideContextMenu();
                    };
                    contextMenu.appendChild(item);
                });

                // Add separator
                const separator = document.createElement('div');
                separator.className = 'context-menu-header';
                separator.textContent = 'Actions';
                contextMenu.appendChild(separator);

                // Add delete option
                const deleteItem = document.createElement('div');
                deleteItem.className = 'context-menu-item';
                deleteItem.textContent = '🗑 Delete Edge';
                deleteItem.style.color = '#e74c3c';
                deleteItem.onclick = () => {
                    cy.remove(target);
                    hideInfoPanel();
                    hideContextMenu();
                };
                contextMenu.appendChild(deleteItem);
            }

            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.classList.add('active');
        }

        // Hide context menu
        function hideContextMenu() {
            contextMenu.classList.remove('active');
            contextMenuTarget = null;
        }

        // Initialize legend on load
        initializeLegend();

        // Helper function to generate unique node ID
        function getNextNodeId() {
            return 'n' + nodeIdCounter++;
        }

        // Helper function to generate unique edge ID
        function getNextEdgeId() {
            return 'e' + edgeIdCounter++;
        }

        // Helper function to show mode indicator
        function showModeIndicator(text, isEdgeMode = false) {
            modeIndicator.textContent = text;
            modeIndicator.classList.add('active');
            if (isEdgeMode) {
                modeIndicator.classList.add('edge-mode');
            } else {
                modeIndicator.classList.remove('edge-mode');
            }
        }

        // Helper function to hide mode indicator
        function hideModeIndicator() {
            modeIndicator.classList.remove('active');
            modeIndicator.classList.remove('edge-mode');
        }

        // Add node at position
        function addNode(x, y) {
            const nodeId = getNextNodeId();
            cy.add({
                group: 'nodes',
                data: {
                    id: nodeId,
                    label: 'New Node',
                    type: 'concept',
                    content: ''  // Markdown content
                },
                position: { x: x, y: y }
            });
            return nodeId;
        }

        // Add edge between two nodes
        function addEdge(sourceId, targetId) {
            const edgeId = getNextEdgeId();
            const edgeType = 'supports';
            cy.add({
                group: 'edges',
                data: {
                    id: edgeId,
                    source: sourceId,
                    target: targetId,
                    label: EDGE_TYPES[edgeType].label,  // Initialize with type name
                    type: edgeType,
                    content: '',  // Markdown content
                    labelMatchesType: true  // Track if label was manually changed
                }
            });
            return edgeId;
        }

        // Change node type
        function changeNodeType(node, newType) {
            if (NODE_TYPES[newType]) {
                node.data('type', newType);
                // Force Cytoscape to re-render
                node.style('shape', NODE_TYPES[newType].shape);
                node.style('background-color', NODE_TYPES[newType].color);
                node.style('border-color', NODE_TYPES[newType].borderColor);
            }
        }

        // Cycle through edge types
        function cycleEdgeType(edge) {
            const currentType = edge.data('type') || 'supports';
            const currentLabel = edge.data('label');
            const currentIndex = EDGE_TYPE_KEYS.indexOf(currentType);
            const nextIndex = (currentIndex + 1) % EDGE_TYPE_KEYS.length;
            const nextType = EDGE_TYPE_KEYS[nextIndex];

            // Check if label matches current type name
            const labelMatchesType = currentLabel === EDGE_TYPES[currentType].label;

            // Update label if it matches the type name
            if (labelMatchesType) {
                edge.data('label', EDGE_TYPES[nextType].label);
                edge.data('labelMatchesType', true);
            } else {
                edge.data('labelMatchesType', false);
            }

            edge.data('type', nextType);
            // Force Cytoscape to re-render
            edge.style('line-color', EDGE_TYPES[nextType].color);
            edge.style('target-arrow-color', EDGE_TYPES[nextType].color);
            edge.style('line-style', EDGE_TYPES[nextType].lineStyle);
            edge.style('width', EDGE_TYPES[nextType].width);

            // Update info panel if this edge is selected
            if (edge.selected()) {
                showInfoPanel(edge);
            }
        }

        // Change edge type
        function changeEdgeType(edge, newType) {
            if (EDGE_TYPES[newType]) {
                const currentType = edge.data('type') || 'supports';
                const currentLabel = edge.data('label');

                // Check if label matches current type name
                const labelMatchesType = currentLabel === EDGE_TYPES[currentType].label;

                // Update label if it matches the type name
                if (labelMatchesType) {
                    edge.data('label', EDGE_TYPES[newType].label);
                    edge.data('labelMatchesType', true);
                } else {
                    edge.data('labelMatchesType', false);
                }

                edge.data('type', newType);
                // Force Cytoscape to re-render
                edge.style('line-color', EDGE_TYPES[newType].color);
                edge.style('target-arrow-color', EDGE_TYPES[newType].color);
                edge.style('line-style', EDGE_TYPES[newType].lineStyle);
                edge.style('width', EDGE_TYPES[newType].width);

                // Update info panel if this edge is selected
                if (edge.selected()) {
                    showInfoPanel(edge);
                }
            }
        }

        // Edit element label (node or edge) with inline editor
        function editElement(element) {
            if (editingElement) return; // Prevent multiple edits at once

            editingElement = element;
            const currentLabel = element.data('label');

            // Position the inline editor exactly at the center of the element
            let renderedPosition;
            if (element.isNode()) {
                renderedPosition = element.renderedPosition();
            } else if (element.isEdge()) {
                renderedPosition = element.renderedMidpoint();
            }

            // Center the input using transform: translate(-50%, -50%)
            inlineEditor.style.left = renderedPosition.x + 'px';
            inlineEditor.style.top = renderedPosition.y + 'px';
            inlineEditor.style.display = 'block';
            inlineEditor.value = currentLabel;

            // Set width based on content
            const textLength = currentLabel.length;
            const minWidth = 80;
            const estimatedWidth = Math.max(minWidth, textLength * 8 + 20);
            inlineEditor.style.width = Math.min(estimatedWidth, 200) + 'px';

            inlineEditor.focus();
            inlineEditor.select();

            // Handle finish editing
            function finishEditing() {
                const newLabel = inlineEditor.value.trim();
                if (newLabel !== '') {
                    element.data('label', newLabel);
                    // If editing an edge, update labelMatchesType flag
                    if (element.isEdge()) {
                        const edgeType = element.data('type') || 'supports';
                        const labelMatchesType = newLabel === EDGE_TYPES[edgeType].label;
                        element.data('labelMatchesType', labelMatchesType);
                    }
                }
                inlineEditor.style.display = 'none';
                editingElement = null;

                // Update info panel if element is still selected
                if (element.selected()) {
                    showInfoPanel(element);
                }
            }

            // Remove previous listeners
            inlineEditor.onblur = null;
            inlineEditor.onkeydown = null;

            // Set new listeners
            inlineEditor.onblur = finishEditing;
            inlineEditor.onkeydown = function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    inlineEditor.style.display = 'none';
                    editingElement = null;
                }
            };
        }

        // Show info panel for selected element
        function showInfoPanel(element) {
            if (!element) {
                infoPanel.classList.remove('active');
                return;
            }

            infoPanel.classList.add('active');

            if (element.isNode()) {
                infoPanelTitle.textContent = 'Node Info';
                const nodeType = element.data('type') || 'concept';
                const nodeLabel = element.data('label') || '';
                const nodeContent = element.data('content') || '';

                // Get connections
                const outgoingEdges = element.connectedEdges('[source = "' + element.id() + '"]');
                const incomingEdges = element.connectedEdges('[target = "' + element.id() + '"]');

                infoPanelContent.innerHTML = `
                    <div class="info-section">
                        <div class="info-label">Type</div>
                        <div class="info-value">${NODE_TYPES[nodeType].label}</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Label</div>
                        <div class="info-value editable" id="info-label-value">${nodeLabel}</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Content (Markdown)</div>
                        <textarea class="info-textarea" id="info-content-textarea">${nodeContent}</textarea>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Outgoing Connections (${outgoingEdges.length})</div>
                        <div class="connection-list" id="outgoing-connections"></div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Incoming Connections (${incomingEdges.length})</div>
                        <div class="connection-list" id="incoming-connections"></div>
                    </div>
                `;

                // Add outgoing connections
                const outgoingList = document.getElementById('outgoing-connections');
                outgoingEdges.forEach(edge => {
                    const target = edge.target();
                    const item = document.createElement('div');
                    item.className = 'connection-item outgoing';
                    item.textContent = `→ ${edge.data('label')} → ${target.data('label')}`;
                    // Make item clickable to navigate to target node
                    item.onclick = function() {
                        cy.elements().unselect();
                        target.select();
                        cy.animate({
                            center: { eles: target },
                            zoom: cy.zoom()
                        }, {
                            duration: 300
                        });
                    };
                    outgoingList.appendChild(item);
                });
                if (outgoingEdges.length === 0) {
                    outgoingList.innerHTML = '<div style="font-size: 11px; color: #999; padding: 4px;">No outgoing connections</div>';
                }

                // Add incoming connections
                const incomingList = document.getElementById('incoming-connections');
                incomingEdges.forEach(edge => {
                    const source = edge.source();
                    const item = document.createElement('div');
                    item.className = 'connection-item incoming';
                    item.textContent = `${source.data('label')} → ${edge.data('label')} →`;
                    // Make item clickable to navigate to source node
                    item.onclick = function() {
                        cy.elements().unselect();
                        source.select();
                        cy.animate({
                            center: { eles: source },
                            zoom: cy.zoom()
                        }, {
                            duration: 300
                        });
                    };
                    incomingList.appendChild(item);
                });
                if (incomingEdges.length === 0) {
                    incomingList.innerHTML = '<div style="font-size: 11px; color: #999; padding: 4px;">No incoming connections</div>';
                }

                // Add click handler for label editing
                document.getElementById('info-label-value').onclick = function() {
                    editElement(element);
                };

                // Add input handler for content textarea (real-time updates)
                document.getElementById('info-content-textarea').oninput = function() {
                    element.data('content', this.value);
                };

            } else if (element.isEdge()) {
                infoPanelTitle.textContent = 'Edge Info';
                const edgeType = element.data('type') || 'supports';
                const edgeLabel = element.data('label') || '';
                const edgeContent = element.data('content') || '';
                const source = element.source();
                const target = element.target();

                infoPanelContent.innerHTML = `
                    <div class="info-section">
                        <div class="info-label">Type</div>
                        <div class="info-value">${EDGE_TYPES[edgeType].label}</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Label</div>
                        <div class="info-value editable" id="info-label-value">${edgeLabel}</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Content (Markdown)</div>
                        <textarea class="info-textarea" id="info-content-textarea">${edgeContent}</textarea>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Source Node</div>
                        <div class="connection-item" id="edge-source-node">${source.data('label')} (${NODE_TYPES[source.data('type')].label})</div>
                    </div>
                    <div class="info-section">
                        <div class="info-label">Target Node</div>
                        <div class="connection-item" id="edge-target-node">${target.data('label')} (${NODE_TYPES[target.data('type')].label})</div>
                    </div>
                `;

                // Add click handler for label editing
                document.getElementById('info-label-value').onclick = function() {
                    editElement(element);
                };

                // Add input handler for content textarea (real-time updates)
                document.getElementById('info-content-textarea').oninput = function() {
                    element.data('content', this.value);
                };

                // Add click handlers for source and target nodes
                document.getElementById('edge-source-node').onclick = function() {
                    cy.elements().unselect();
                    source.select();
                    cy.animate({
                        center: { eles: source },
                        zoom: cy.zoom()
                    }, {
                        duration: 300
                    });
                };

                document.getElementById('edge-target-node').onclick = function() {
                    cy.elements().unselect();
                    target.select();
                    cy.animate({
                        center: { eles: target },
                        zoom: cy.zoom()
                    }, {
                        duration: 300
                    });
                };
            }
        }

        // Hide info panel
        function hideInfoPanel() {
            infoPanel.classList.remove('active');
        }

        // Delete selected elements
        function deleteSelected() {
            const selected = cy.$(':selected');
            if (selected.length > 0) {
                cy.remove(selected);
                hideInfoPanel();
            }
        }

        // Enter edge creation mode
        function enterEdgeMode() {
            const selected = cy.$('node:selected');
            if (selected.length !== 1) {
                alert('Please select exactly one node as the source for the edge.');
                return;
            }

            edgeMode = true;
            edgeModeSourceNode = selected[0];
            showModeIndicator(`Edge Mode: Click target node (source: ${edgeModeSourceNode.data('label')})`, true);
        }

        // Exit edge creation mode
        function exitEdgeMode() {
            edgeMode = false;
            edgeModeSourceNode = null;
            hideModeIndicator();
        }

        // Save graph to JSON
        function saveGraph() {
            const graphData = {
                nodes: [],
                edges: []
            };

            cy.nodes().forEach(node => {
                graphData.nodes.push({
                    id: node.data('id'),
                    label: node.data('label'),
                    type: node.data('type'),
                    content: node.data('content') || '',
                    position: node.position()
                });
            });

            cy.edges().forEach(edge => {
                graphData.edges.push({
                    id: edge.data('id'),
                    source: edge.data('source'),
                    target: edge.data('target'),
                    label: edge.data('label'),
                    type: edge.data('type'),
                    content: edge.data('content') || '',
                    labelMatchesType: edge.data('labelMatchesType') || false
                });
            });

            const jsonString = JSON.stringify(graphData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'l-lang-graph.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Load graph from JSON
        function loadGraph(jsonData) {
            try {
                const graphData = JSON.parse(jsonData);

                // Clear existing graph
                cy.elements().remove();

                // Reset counters
                nodeIdCounter = 1;
                edgeIdCounter = 1;

                // Add nodes
                if (graphData.nodes) {
                    graphData.nodes.forEach(nodeData => {
                        cy.add({
                            group: 'nodes',
                            data: {
                                id: nodeData.id,
                                label: nodeData.label,
                                type: nodeData.type || 'concept',
                                content: nodeData.content || ''
                            },
                            position: nodeData.position || { x: 100, y: 100 }
                        });

                        // Update counter to avoid ID conflicts
                        const idNum = parseInt(nodeData.id.substring(1));
                        if (idNum >= nodeIdCounter) {
                            nodeIdCounter = idNum + 1;
                        }
                    });
                }

                // Add edges
                if (graphData.edges) {
                    graphData.edges.forEach(edgeData => {
                        const edgeType = edgeData.type || 'supports';
                        const edgeLabel = edgeData.label || EDGE_TYPES[edgeType].label;
                        // Check if label matches type
                        const labelMatchesType = edgeData.labelMatchesType !== undefined
                            ? edgeData.labelMatchesType
                            : (edgeLabel === EDGE_TYPES[edgeType].label);

                        cy.add({
                            group: 'edges',
                            data: {
                                id: edgeData.id,
                                source: edgeData.source,
                                target: edgeData.target,
                                label: edgeLabel,
                                type: edgeType,
                                content: edgeData.content || '',
                                labelMatchesType: labelMatchesType
                            }
                        });

                        // Update counter to avoid ID conflicts
                        const idNum = parseInt(edgeData.id.substring(1));
                        if (idNum >= edgeIdCounter) {
                            edgeIdCounter = idNum + 1;
                        }
                    });
                }

                // Fit graph to viewport
                if (cy.elements().length > 0) {
                    cy.fit(cy.elements(), 50);
                }

            } catch (error) {
                alert('Error loading graph: ' + error.message);
            }
        }

        // Event Listeners

        // Click on canvas (for adding nodes or creating edges)
        cy.on('tap', function(event) {
            // Check if clicked on background
            if (event.target === cy) {
                if (!edgeMode) {
                    // Add new node at click position
                    const pos = event.position;
                    addNode(pos.x, pos.y);
                } else {
                    // Exit edge mode if clicking on background
                    exitEdgeMode();
                }
            }
            // Check if clicked on node while in edge mode
            else if (event.target.isNode() && edgeMode) {
                const targetNode = event.target;
                if (targetNode.id() !== edgeModeSourceNode.id()) {
                    addEdge(edgeModeSourceNode.id(), targetNode.id());
                }
                exitEdgeMode();
            }
        });

        // Double-click to edit
        cy.on('dbltap', 'node, edge', function(event) {
            event.preventDefault();
            event.stopPropagation();
            editElement(event.target);
        });

        // Right-click (context menu) on nodes and edges
        cy.on('cxttap', 'node, edge', function(event) {
            event.preventDefault();
            const target = event.target;
            const renderedPosition = event.renderedPosition || event.position;
            showContextMenu(renderedPosition.x, renderedPosition.y, target);
        });

        // Click anywhere to hide context menu
        document.addEventListener('click', function(event) {
            if (!contextMenu.contains(event.target)) {
                hideContextMenu();
            }
        });

        // Prevent default browser context menu
        document.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });

        // Hide context menu on canvas click
        cy.on('tap', function(event) {
            hideContextMenu();
        });

        // Show info panel when selecting a node or edge
        cy.on('select', 'node, edge', function(event) {
            const element = event.target;
            showInfoPanel(element);
        });

        // Hide info panel when unselecting
        cy.on('unselect', 'node, edge', function(event) {
            const selected = cy.$(':selected');
            if (selected.length === 0) {
                hideInfoPanel();
            }
        });

        // Info panel close button
        infoPanelClose.addEventListener('click', function() {
            hideInfoPanel();
            cy.$(':selected').unselect();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Prevent shortcuts when editing
            if (editingElement) return;

            // Prevent shortcuts when typing in textarea or input
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'INPUT')) {
                return;
            }

            // N key - Add node at center
            if (event.key === 'n' || event.key === 'N') {
                const center = {
                    x: cy.width() / 2,
                    y: cy.height() / 2
                };
                const modelPosition = cy.pan();
                const zoom = cy.zoom();
                addNode(
                    (center.x - modelPosition.x) / zoom,
                    (center.y - modelPosition.y) / zoom
                );
            }

            // E key - Enter edge mode
            if (event.key === 'e' || event.key === 'E') {
                if (!edgeMode) {
                    enterEdgeMode();
                }
            }

            // Escape key - Exit edge mode
            if (event.key === 'Escape') {
                if (edgeMode) {
                    exitEdgeMode();
                }
            }

            // Delete key - Delete selected
            if (event.key === 'Delete' || event.key === 'Backspace') {
                event.preventDefault();
                deleteSelected();
            }

            // 1-5 keys - Change node type
            if (['1', '2', '3', '4', '5'].includes(event.key)) {
                const selected = cy.$('node:selected');
                if (selected.length === 1) {
                    const typeIndex = parseInt(event.key) - 1;
                    const newType = NODE_TYPE_KEYS[typeIndex];
                    if (newType) {
                        changeNodeType(selected[0], newType);
                    }
                }
            }

            // T key - Cycle edge type
            if (event.key === 't' || event.key === 'T') {
                const selected = cy.$('edge:selected');
                if (selected.length === 1) {
                    cycleEdgeType(selected[0]);
                }
            }

            // Ctrl+S - Save
            if ((event.ctrlKey || event.metaKey) && event.key === 's') {
                event.preventDefault();
                saveGraph();
            }
        });

        // Button event listeners
        document.getElementById('add-node-btn').addEventListener('click', function() {
            const center = {
                x: cy.width() / 2,
                y: cy.height() / 2
            };
            const modelPosition = cy.pan();
            const zoom = cy.zoom();
            addNode(
                (center.x - modelPosition.x) / zoom,
                (center.y - modelPosition.y) / zoom
            );
        });

        document.getElementById('save-btn').addEventListener('click', saveGraph);

        document.getElementById('load-btn').addEventListener('click', function() {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    loadGraph(e.target.result);
                };
                reader.readAsText(file);
            }
            // Reset file input so the same file can be loaded again
            event.target.value = '';
        });

        document.getElementById('clear-btn').addEventListener('click', function() {
            if (confirm('Are you sure you want to clear the entire graph?')) {
                cy.elements().remove();
                nodeIdCounter = 1;
                edgeIdCounter = 1;
            }
        });

        // Initialize with a sample graph
        function loadSampleGraph() {
            const sampleData = {
                "nodes": [
                    {"id": "n1", "label": "Concept A", "type": "concept", "content": "This is a concept node", "position": {"x": 200, "y": 150}},
                    {"id": "n2", "label": "Claim B", "type": "claim", "content": "This represents a claim", "position": {"x": 400, "y": 150}},
                    {"id": "n3", "label": "Evidence C", "type": "evidence", "content": "Supporting evidence", "position": {"x": 300, "y": 300}}
                ],
                "edges": [
                    {"id": "e1", "source": "n1", "target": "n2", "label": "derives from", "type": "derives_from", "content": "", "labelMatchesType": true},
                    {"id": "e2", "source": "n3", "target": "n1", "label": "supports", "type": "supports", "content": "", "labelMatchesType": true}
                ]
            };
            loadGraph(JSON.stringify(sampleData));
        }

        // Load sample graph on startup
        loadSampleGraph();
    </script>
</body>
</html>
